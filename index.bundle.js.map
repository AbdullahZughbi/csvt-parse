{
  "version": 3,
  "sources": ["../src/types/string.ts", "../src/lib/errors.ts", "../src/types/number.ts", "../src/types/boolean.ts", "../src/types/array.ts", "../src/types/json.ts", "../src/types/void.ts", "../src/types/date.ts", "../src/types/datetime.ts", "../src/types/url.ts", "../src/types/hexcolor.ts", "../src/types/email.ts", "../src/types/time.ts", "../src/types/rgba.ts", "../src/types/color.ts", "../src/types/uuid.ts", "../src/types/ipaddress.ts", "../src/types/percentage.ts", "../src/types/enum.ts", "../src/types/union.ts", "../src/types/any.ts", "../src/types/text.ts", "../src/types/varchar.ts", "../src/types/char.ts", "../src/lib/validation.ts", "../src/lib/parse.ts", "../src/lib/readFile.ts", "../src/lib/writeFile.ts", "../src/index.ts"],
  "sourcesContent": ["/**\n * String type validator\n */\n\nimport { TypeValidator } from './index';\n\nexport class StringValidator implements TypeValidator {\n    validate(_value: string): boolean {\n        // All values can be treated as strings\n        return true;\n    }\n\n    parse(value: string): string {\n        return value;\n    }\n\n    serialize(value: any): string {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        return String(value);\n    }\n};\n", "/**\n * Error classes for CSVT parsing\n */\n\nexport class CSVTError extends Error {\n    public readonly code: string;\n    public readonly line: number | undefined;\n    public readonly column: string | undefined;\n\n    constructor(message: string, code: string = 'CSVT_ERROR', line?: number, column?: string) {\n        super(message);\n        this.name = 'CSVTError';\n        this.code = code;\n        this.line = line;\n        this.column = column;\n        \n        // Maintain proper stack trace for where our error was thrown (only available on V8)\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, CSVTError);\n        }\n    }\n};\n\nexport class ValidationError extends CSVTError {\n    public readonly expectedType: string;\n    public readonly actualValue: any;\n\n    constructor(\n        message: string, \n        expectedType: string, \n        actualValue: any, \n        line?: number, \n        column?: string\n    ) {\n        super(message, 'VALIDATION_ERROR', line, column);\n        this.name = 'ValidationError';\n        this.expectedType = expectedType;\n        this.actualValue = actualValue;\n    }\n};\n\nexport class ParseError extends CSVTError {\n    public readonly rawData: string;\n\n    constructor(message: string, rawData: string, line?: number, column?: string) {\n        super(message, 'PARSE_ERROR', line, column);\n        this.name = 'ParseError';\n        this.rawData = rawData;\n    }\n};\n\nexport class FileError extends CSVTError {\n    public readonly filename: string;\n    public readonly operation: 'read' | 'write';\n\n    constructor(message: string, filename: string, operation: 'read' | 'write') {\n        super(message, 'FILE_ERROR');\n        this.name = 'FileError';\n        this.filename = filename;\n        this.operation = operation;\n    }\n};\n", "/**\n * Number type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nexport class NumberValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (value === null || value === undefined) {\n            return false;\n        }\n        \n        const trimmed = value.trim();\n        if (trimmed === '') {\n            return false;\n        }\n        \n        const num = Number(trimmed);\n        return !isNaN(num) && Number.isFinite(num);\n    }\n\n    parse(value: string): number {\n        const trimmed = value.trim();\n        \n        if (trimmed === '') {\n            throw new ValidationError('Empty string cannot be parsed as number', 'number', value);\n        }\n        \n        const num = Number(trimmed);\n        \n        if (isNaN(num) || !Number.isFinite(num)) {\n            throw new ValidationError(`Invalid number format: \"${value}\"`, 'number', value);\n        }\n        \n        return num;\n    }\n\n    serialize(value: any): string {\n        if (typeof value === 'number') {\n            if (!Number.isFinite(value)) {\n                throw new Error(`Cannot serialize non-finite number: ${value}`);\n            }\n            return value.toString();\n        }\n        \n        if (typeof value === 'string') {\n            const parsed = this.parse(value);\n            return parsed.toString();\n        }\n        \n        throw new Error(`Cannot serialize \"${value}\" as number`);\n    }\n};\n", "/**\n * Boolean type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nexport class BooleanValidator implements TypeValidator {\n    private static readonly TRUE_VALUES = ['true', '1', 'yes', 'y', 'on'];\n    private static readonly FALSE_VALUES = ['false', '0', 'no', 'n', 'off'];\n\n    validate(value: string): boolean {\n        if (value === null || value === undefined) {\n            return false;\n        }\n        \n        const trimmed = value.trim().toLowerCase();\n        return BooleanValidator.TRUE_VALUES.includes(trimmed) || \n               BooleanValidator.FALSE_VALUES.includes(trimmed);\n    }\n\n    parse(value: string): boolean {\n        const trimmed = value.trim().toLowerCase();\n        \n        if (BooleanValidator.TRUE_VALUES.includes(trimmed)) {\n            return true;\n        }\n        \n        if (BooleanValidator.FALSE_VALUES.includes(trimmed)) {\n            return false;\n        }\n        \n        throw new ValidationError(\n            `Invalid boolean value: \"${value}\". Expected: true, false, 1, 0, yes, no, y, n, on, off`,\n            'boolean',\n            value\n        );\n    }\n\n    serialize(value: any): string {\n        if (typeof value === 'boolean') {\n            return value.toString();\n        }\n        \n        if (typeof value === 'string') {\n            const parsed = this.parse(value);\n            return parsed.toString();\n        }\n        \n        if (typeof value === 'number') {\n            return (value !== 0).toString();\n        }\n        \n        return Boolean(value).toString();\n    }\n};\n", "/**\n * Array type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nexport class ArrayValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (value === null || value === undefined) {\n            return false;\n        }\n        \n        const trimmed = value.trim();\n        \n        // Check if it looks like a JSON array\n        if (trimmed.startsWith('[') && trimmed.endsWith(']')) {\n            try {\n                const parsed = JSON.parse(trimmed);\n                return Array.isArray(parsed);\n            } catch {\n                return false;\n            }\n        }\n        \n        return false;\n    }\n\n    parse(value: string): any[] {\n        const trimmed = value.trim();\n        \n        if (!trimmed.startsWith('[') || !trimmed.endsWith(']')) {\n            throw new ValidationError(\n                `Invalid array format: \"${value}\". Expected JSON array format like [\"item1\", \"item2\"]`,\n                'array',\n                value\n            );\n        }\n        \n        try {\n            const parsed = JSON.parse(trimmed);\n            \n            if (!Array.isArray(parsed)) {\n                throw new ValidationError(\n                    `Parsed value is not an array: \"${value}\"`,\n                    'array',\n                    value\n                );\n            }\n            \n            return parsed;\n        } catch (error) {\n            if (error instanceof ValidationError) {\n                throw error;\n            }\n            \n            throw new ValidationError(\n                `Failed to parse array: \"${value}\". ${error instanceof Error ? error.message : 'Invalid JSON'}`,\n                'array',\n                value\n            );\n        }\n    }\n\n    serialize(value: any): string {\n        if (Array.isArray(value)) {\n            return JSON.stringify(value);\n        }\n        \n        if (typeof value === 'string' && this.validate(value)) {\n            // Already a valid array string\n            return value;\n        }\n        \n        throw new Error(`Cannot serialize \"${value}\" as array`);\n    }\n};\n", "/**\n * JSON type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nexport class JsonValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (value === null || value === undefined) {\n            return false;\n        }\n        \n        const trimmed = value.trim();\n        \n        // Check if it looks like a JSON object\n        if (trimmed.startsWith('{') && trimmed.endsWith('}')) {\n            try {\n                const parsed = JSON.parse(trimmed);\n                return typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed);\n            } catch {\n                return false;\n            }\n        }\n        \n        return false;\n    }\n\n    parse(value: string): any {\n        const trimmed = value.trim();\n        \n        if (!trimmed.startsWith('{') || !trimmed.endsWith('}')) {\n            throw new ValidationError(\n                `Invalid JSON format: \"${value}\". Expected JSON object format like {\"key\": \"value\"}`,\n                'json',\n                value\n            );\n        }\n        \n        try {\n            const parsed = JSON.parse(trimmed);\n            \n            if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {\n                throw new ValidationError(\n                    `Parsed value is not a JSON object: \"${value}\"`,\n                    'json',\n                    value\n                );\n            }\n            \n            return parsed;\n        } catch (error) {\n            if (error instanceof ValidationError) {\n                throw error;\n            }\n            \n            throw new ValidationError(\n                `Failed to parse JSON: \"${value}\". ${error instanceof Error ? error.message : 'Invalid JSON'}`,\n                'json',\n                value\n            );\n        }\n    }\n\n    serialize(value: any): string {\n        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n            return JSON.stringify(value);\n        }\n        \n        if (typeof value === 'string' && this.validate(value)) {\n            // Already a valid JSON string\n            return value;\n        }\n        \n        throw new Error(`Cannot serialize \"${value}\" as JSON object`);\n    }\n};\n", "/**\n * Void type validator - represents null/undefined values\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nexport class VoidValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (value === null || value === undefined) {\n            return true;\n        }\n        \n        const trimmed = value.trim().toLowerCase();\n        return trimmed === '' || trimmed === 'null' || trimmed === 'undefined';\n    }\n\n    parse(value: string): null {\n        if (!this.validate(value)) {\n            throw new ValidationError(\n                `Invalid void value: \"${value}\". Expected empty string, null, or undefined`,\n                'void',\n                value\n            );\n        }\n        \n        return null;\n    }\n\n    serialize(value: any): string {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        \n        throw new Error(`Cannot serialize non-void value: ${JSON.stringify(value)}`);\n    }\n};\n", "/**\n * Date type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nexport class DateValidator implements TypeValidator {\n    // Validates strings like 'YYYY-MM-DD'\n    validate(value: string): boolean {\n        if (value === null || value === undefined || value.trim() === '') {\n            return false;\n        }\n        const trimmed = value.trim();\n\n        // Simple ISO date pattern (no time)\n        const isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n        if (!isoDateRegex.test(trimmed)) {\n            return false;\n        }\n\n        // Check if Date parses correctly and matches input (to reject invalid dates like 2023-02-30)\n        const date = new Date(trimmed);\n        if (isNaN(date.getTime())) {\n            return false;\n        }\n\n        // Cross-check components to avoid JS auto-correcting invalid dates\n        const [year, month, day] = trimmed.split('-').map(Number);\n        return date.getUTCFullYear() === year &&\n               date.getUTCMonth() + 1 === month &&\n               date.getUTCDate() === day;\n    }\n\n    parse(value: string): Date {\n        if (!this.validate(value)) {\n            throw new ValidationError(\n                `Invalid date format: \"${value}\". Expected format: YYYY-MM-DD`,\n                'date',\n                value\n            );\n        }\n        return new Date(value);\n    }\n\n    serialize(value: any): string {\n        if (!(value instanceof Date)) {\n            throw new Error(`Cannot serialize non-Date value: ${JSON.stringify(value)}`);\n        }\n        if (isNaN(value.getTime())) {\n            throw new Error(`Cannot serialize invalid Date: ${value}`);\n        }\n        // Return ISO date string without time portion\n        return value.toISOString().slice(0, 10);\n    }\n};\n", "/**\n * DateTime type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nexport class DateTimeValidator implements TypeValidator {\n    // Validates ISO 8601 datetime strings like 'YYYY-MM-DDTHH:mm:ss.sssZ' or 'YYYY-MM-DD HH:mm:ss'\n    validate(value: string): boolean {\n        if (value === null || value === undefined || value.trim() === '') {\n            return false;\n        }\n        const trimmed = value.trim();\n\n        // Try to parse as Date\n        const date = new Date(trimmed);\n        return !isNaN(date.getTime());\n    }\n\n    parse(value: string): Date {\n        if (!this.validate(value)) {\n            throw new ValidationError(\n                `Invalid datetime format: \"${value}\". Expected ISO 8601 format`,\n                'datetime',\n                value\n            );\n        }\n        return new Date(value);\n    }\n\n    serialize(value: any): string {\n        if (!(value instanceof Date)) {\n            throw new Error(`Cannot serialize non-Date value: ${JSON.stringify(value)}`);\n        }\n        if (isNaN(value.getTime())) {\n            throw new Error(`Cannot serialize invalid Date: ${value}`);\n        }\n        // Return full ISO string\n        return value.toISOString();\n    }\n};\n", "/**\n * URL type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nexport class UrlValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (!value) return false;\n        try {\n            const url = new URL(value.trim());\n            return url.protocol === 'http:' || url.protocol === 'https:';\n        } catch {\n            return false;\n        }\n    }\n\n    parse(value: string): string {\n        if (!this.validate(value)) {\n            throw new ValidationError(`Invalid URL format: \"${value}\"`, 'url', value);\n        }\n        return value.trim();\n    }\n\n    serialize(value: any): string {\n        if (typeof value !== 'string' || !this.validate(value)) {\n            throw new Error(`Cannot serialize invalid URL: ${JSON.stringify(value)}`);\n        }\n        return value;\n    }\n};\n", "/**\n * Hex color type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nconst HEXCOLOR_REGEX = /^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/;\n\nexport class HexColorValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (!value) return false;\n        return HEXCOLOR_REGEX.test(value.trim());\n    }\n\n    parse(value: string): string {\n        if (!this.validate(value)) {\n            throw new ValidationError(`Invalid hex color format: \"${value}\"`, 'hexcolor', value);\n        }\n        return value.trim().toLowerCase();\n    }\n\n    serialize(value: any): string {\n        if (typeof value !== 'string' || !this.validate(value)) {\n            throw new Error(`Cannot serialize invalid hex color: ${JSON.stringify(value)}`);\n        }\n        return value.toLowerCase();\n    }\n};\n", "/**\n * Email type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nconst EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\nexport class EmailValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (!value) return false;\n        return EMAIL_REGEX.test(value.trim());\n    }\n\n    parse(value: string): string {\n        if (!this.validate(value)) {\n            throw new ValidationError(`Invalid email format: \"${value}\"`, 'email', value);\n        }\n        return value.trim();\n    }\n\n    serialize(value: any): string {\n        if (typeof value !== 'string' || !this.validate(value)) {\n            throw new Error(`Cannot serialize invalid email: ${JSON.stringify(value)}`);\n        }\n        return value;\n    }\n};\n", "/**\n * Time type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nexport class TimeValidator implements TypeValidator {\n    // Validates strings like 'HH:mm:ss' or 'HH:mm'\n    validate(value: string): boolean {\n        if (value === null || value === undefined || value.trim() === '') {\n            return false;\n        }\n        const trimmed = value.trim();\n\n        // Time pattern HH:mm or HH:mm:ss\n        const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;\n        return timeRegex.test(trimmed);\n    }\n\n    parse(value: string): string {\n        if (!this.validate(value)) {\n            throw new ValidationError(\n                `Invalid time format: \"${value}\". Expected format: HH:mm or HH:mm:ss`,\n                'time',\n                value\n            );\n        }\n        return value.trim();\n    }\n\n    serialize(value: any): string {\n        if (typeof value !== 'string' || !this.validate(value)) {\n            throw new Error(`Cannot serialize invalid time value: ${JSON.stringify(value)}`);\n        }\n        return value;\n    }\n};\n", "/**\n * RGBA color validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nconst RGBA_REGEX = /^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(0?\\.\\d+|1|0))?\\s*\\)$/i;\n\nexport class RgbaValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (!value) return false;\n        return RGBA_REGEX.test(value.trim());\n    }\n\n    parse(value: string): string {\n        const trimmed = value.trim();\n        if (!this.validate(trimmed)) {\n            throw new ValidationError(\n                `Invalid RGBA format: \"${value}\". Expected format: rgba(r,g,b,a) or rgb(r,g,b)`,\n                'rgba',\n                value\n            );\n        }\n        return trimmed;\n    }\n\n    serialize(value: any): string {\n        if (typeof value !== 'string' || !this.validate(value)) {\n            throw new Error(`Cannot serialize invalid RGBA value: ${JSON.stringify(value)}`);\n        }\n        return value;\n    }\n};\n", "/**\n * Color validator - hex (#RGB, #RRGGBB) or CSS named colors\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nconst HEX_COLOR_REGEX = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i;\n\n// Partial CSS named colors list for example; you can expand as needed.\nconst CSS_COLOR_NAMES = new Set([\n    'black', 'white', 'red', 'green', 'blue', 'yellow', 'cyan', 'magenta',\n    'orange', 'purple', 'pink', 'gray', 'brown', 'lime', 'navy', 'teal'\n]);\n\nexport class ColorValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (!value) return false;\n        const trimmed = value.trim().toLowerCase();\n        return HEX_COLOR_REGEX.test(trimmed) || CSS_COLOR_NAMES.has(trimmed);\n    }\n\n    parse(value: string): string {\n        const trimmed = value.trim();\n        if (!this.validate(trimmed)) {\n            throw new ValidationError(\n                `Invalid color format: \"${value}\". Expected hex (#RGB or #RRGGBB) or CSS named color`,\n                'color',\n                value\n            );\n        }\n        return trimmed;\n    }\n\n    serialize(value: any): string {\n        if (typeof value !== 'string' || !this.validate(value)) {\n            throw new Error(`Cannot serialize invalid color value: ${value}`);\n        }\n        return value;\n    }\n};\n", "/**\n * UUID type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\nexport class UUIDValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (!value) return false;\n        return UUID_REGEX.test(value.trim());\n    }\n\n    parse(value: string): string {\n        if (!this.validate(value)) {\n            throw new ValidationError(`Invalid UUID format: \"${value}\"`, 'uuid', value);\n        }\n        return value.trim().toLowerCase();\n    }\n\n    serialize(value: any): string {\n        if (typeof value !== 'string' || !this.validate(value)) {\n            throw new Error(`Cannot serialize invalid UUID: ${JSON.stringify(value)}`);\n        }\n        return value.toLowerCase();\n    }\n};\n", "/**\n * IP Address type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nconst IPV4_REGEX = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\nconst IPV6_REGEX = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;\n\nexport class IPAddressValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (!value) return false;\n        const trimmed = value.trim();\n        return IPV4_REGEX.test(trimmed) || IPV6_REGEX.test(trimmed);\n    }\n\n    parse(value: string): string {\n        if (!this.validate(value)) {\n            throw new ValidationError(`Invalid IP address format: \"${value}\"`, 'ipaddress', value);\n        }\n        return value.trim();\n    }\n\n    serialize(value: any): string {\n        if (typeof value !== 'string' || !this.validate(value)) {\n            throw new Error(`Cannot serialize invalid IP address: ${JSON.stringify(value)}`);\n        }\n        return value;\n    }\n};\n", "/**\n * Percentage type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nconst PERCENTAGE_REGEX = /^(\\d+(?:\\.\\d+)?)%$/;\n\nexport class PercentageValidator implements TypeValidator {\n    validate(value: string): boolean {\n        if (!value) return false;\n        return PERCENTAGE_REGEX.test(value.trim());\n    }\n\n    parse(value: string): number {\n        const trimmed = value.trim();\n        if (!this.validate(trimmed)) {\n            throw new ValidationError(`Invalid percentage format: \"${value}\". Expected format: 50%`, 'percentage', value);\n        }\n        \n        const match = trimmed.match(PERCENTAGE_REGEX);\n        if (!match) {\n            throw new ValidationError(`Invalid percentage format: \"${value}\"`, 'percentage', value);\n        }\n        \n        return parseFloat(match[1]!) / 100;\n    }\n\n    serialize(value: any): string {\n        if (typeof value === 'number') {\n            return `${(value * 100).toString()}%`;\n        }\n        \n        if (typeof value === 'string' && this.validate(value)) {\n            return value;\n        }\n        \n        throw new Error(`Cannot serialize invalid percentage: ${JSON.stringify(value)}`);\n    }\n};\n", "/**\n * Enum type validator\n */\n\nimport { TypeValidator } from './index';\nimport { ValidationError } from '../lib/errors';\n\nexport class EnumValidator implements TypeValidator {\n    validate(value: string, options?: { enumValues?: string[] }): boolean {\n        if (value === null || value === undefined) {\n            return false;\n        }\n        \n        if (!options?.enumValues || !Array.isArray(options.enumValues)) {\n            return false;\n        }\n        \n        const trimmed = value.trim();\n        return options.enumValues.includes(trimmed);\n    }\n\n    parse(value: string, options?: { enumValues?: string[] }): string {\n        if (!options?.enumValues || !Array.isArray(options.enumValues)) {\n            throw new ValidationError(\n                'Enum validator requires enumValues option',\n                'enum',\n                value\n            );\n        }\n        \n        const trimmed = value.trim();\n        \n        if (!options.enumValues.includes(trimmed)) {\n            throw new ValidationError(\n                `Invalid enum value: \"${value}\". Expected one of: ${options.enumValues.join(', ')}`,\n                'enum',\n                value\n            );\n        }\n        \n        return trimmed;\n    }\n\n    serialize(value: any, options?: { enumValues?: string[] }): string {\n        if (typeof value !== 'string') {\n            throw new Error(`Cannot serialize non-string value as enum: ${JSON.stringify(value)}`);\n        }\n        \n        if (!options?.enumValues || !Array.isArray(options.enumValues)) {\n            throw new Error('Enum validator requires enumValues option for serialization');\n        }\n        \n        if (!options.enumValues.includes(value)) {\n            throw new Error(`Cannot serialize invalid enum value: ${value}. Expected one of: ${options.enumValues.join(', ')}`);\n        }\n        \n        return value;\n    }\n};\n", "/**\n * Union type validator\n */\n\nimport { TypeValidator, SupportedType } from './index';\nimport { ValidationError } from '../lib/errors';\nimport { getValidator } from '../lib/validation';\n\nexport class UnionValidator implements TypeValidator {\n    validate(value: string, options?: { unionTypes?: SupportedType[] }): boolean {\n        if (value === null || value === undefined) {\n            return false;\n        }\n        \n        if (!options?.unionTypes || !Array.isArray(options.unionTypes)) {\n            return false;\n        }\n        \n        // Check if value is valid for any of the union types\n        for (const type of options.unionTypes) {\n            try {\n                const validator = getValidator(type);\n                if (validator.validate(value)) {\n                    return true;\n                }\n            } catch {\n                // Continue to next type if validator fails\n                continue;\n            }\n        }\n        \n        return false;\n    }\n\n    parse(value: string, options?: { unionTypes?: SupportedType[] }): any {\n        if (!options?.unionTypes || !Array.isArray(options.unionTypes)) {\n            throw new ValidationError(\n                'Union validator requires unionTypes option',\n                'union',\n                value\n            );\n        }\n        \n        const errors: string[] = [];\n        \n        // Try to parse with each type in the union\n        for (const type of options.unionTypes) {\n            try {\n                const validator = getValidator(type);\n                if (validator.validate(value)) {\n                    return validator.parse(value);\n                }\n            } catch (error) {\n                errors.push(`${type}: ${error instanceof Error ? error.message : String(error)}`);\n                continue;\n            }\n        }\n        \n        throw new ValidationError(\n            `Value \"${value}\" does not match any type in union [${options.unionTypes.join('|')}]. Errors: ${errors.join('; ')}`,\n            'union',\n            value\n        );\n    }\n\n    serialize(value: any, options?: { unionTypes?: SupportedType[] }): string {\n        if (!options?.unionTypes || !Array.isArray(options.unionTypes)) {\n            throw new Error('Union validator requires unionTypes option for serialization');\n        }\n        \n        // Try to serialize with each type in the union\n        for (const type of options.unionTypes) {\n            try {\n                const validator = getValidator(type);\n                return validator.serialize(value);\n            } catch {\n                // Continue to next type if serialization fails\n                continue;\n            }\n        }\n        \n        throw new Error(`Cannot serialize value as any type in union [${options.unionTypes.join('|')}]: ${JSON.stringify(value)}`);\n    }\n};\n", "/**\n * Any type validator - accepts all values\n */\n\nimport { TypeValidator } from './index';\n\nexport class AnyValidator implements TypeValidator {\n    validate(_value: string): boolean {\n        // Any type accepts all values\n        return true;\n    }\n\n    parse(value: string): any {\n        const trimmed = value.trim();\n        \n        // Try to parse as different types in order of specificity\n        // 1. JSON objects/arrays\n        if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || \n            (trimmed.startsWith('[') && trimmed.endsWith(']'))) {\n            try {\n                return JSON.parse(trimmed);\n            } catch {\n                // If JSON parsing fails, return as string\n            }\n        }\n        \n        // 2. Numbers\n        if (!isNaN(Number(trimmed)) && trimmed !== '') {\n            const num = Number(trimmed);\n            if (Number.isFinite(num)) {\n                return num;\n            }\n        }\n        \n        // 3. Booleans\n        const lowerTrimmed = trimmed.toLowerCase();\n        if (['true', 'false', '1', '0', 'yes', 'no', 'y', 'n', 'on', 'off'].includes(lowerTrimmed)) {\n            return ['true', '1', 'yes', 'y', 'on'].includes(lowerTrimmed);\n        }\n        \n        // 4. Return as string for everything else\n        return trimmed;\n    }\n\n    serialize(value: any): string {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        \n        if (typeof value === 'string') {\n            return value;\n        }\n        \n        if (typeof value === 'number' || typeof value === 'boolean') {\n            return String(value);\n        }\n        \n        if (typeof value === 'object') {\n            return JSON.stringify(value);\n        }\n        \n        return String(value);\n    }\n};\n", "/**\n * TEXT type validator - Unlimited text (alias to string with better semantics)\n */\n\nimport { TypeValidator } from './index';\n\nexport class TextValidator implements TypeValidator {\n    validate(_value: string): boolean {\n        // TEXT accepts any string length\n        return true;\n    }\n\n    parse(value: string): string {\n        // TEXT preserves the exact string\n        return value;\n    }\n\n    serialize(value: any): string {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        return String(value);\n    }\n};\n", "/**\n * VARCHAR(n) type validator - Variable-length string with maximum length\n */\n\nimport { TypeValidator } from './index';\n\nexport class VarcharValidator implements TypeValidator {\n    validate(value: string, options?: { maxLength?: number }): boolean {\n        if (!options?.maxLength) {\n            return true; // If no max length specified, treat as regular string\n        }\n        \n        return value.length <= options.maxLength;\n    }\n\n    parse(value: string, _options?: { maxLength?: number }): string {\n        // VARCHAR stores the exact string without padding\n        return value;\n    }\n\n    serialize(value: any, options?: { maxLength?: number }): string {\n        const stringValue = value === null || value === undefined ? '' : String(value);\n        \n        // Truncate if exceeds max length during serialization\n        if (options?.maxLength && stringValue.length > options.maxLength) {\n            return stringValue.substring(0, options.maxLength);\n        }\n        \n        return stringValue;\n    }\n};\n", "/**\n * CHAR(n) type validator - Fixed-length string, padded to exact length\n */\n\nimport { TypeValidator } from './index';\n\nexport class CharValidator implements TypeValidator {\n    validate(value: string, options?: { length?: number }): boolean {\n        if (!options?.length) {\n            return true; // If no length specified, treat as regular string\n        }\n        \n        // CHAR can accept strings up to the specified length\n        return value.length <= options.length;\n    }\n\n    parse(value: string, options?: { length?: number }): string {\n        if (!options?.length) {\n            return value;\n        }\n        \n        // CHAR pads with spaces to reach exact length\n        if (value.length < options.length) {\n            return value.padEnd(options.length, ' ');\n        }\n        \n        // If longer than specified length, truncate\n        if (value.length > options.length) {\n            return value.substring(0, options.length);\n        }\n        \n        return value;\n    }\n\n    serialize(value: any, options?: { length?: number }): string {\n        const stringValue = value === null || value === undefined ? '' : String(value);\n        \n        if (!options?.length) {\n            return stringValue;\n        }\n        \n        // CHAR always pads to exact length\n        if (stringValue.length < options.length) {\n            return stringValue.padEnd(options.length, ' ');\n        }\n        \n        // Truncate if exceeds length\n        if (stringValue.length > options.length) {\n            return stringValue.substring(0, options.length);\n        }\n        \n        return stringValue;\n    }\n};\n", "/**\n * Validation utilities\n */\n\nimport { SupportedType, TypeValidator, CSVTColumn } from '../types';\nimport { StringValidator } from '../types/string';\nimport { NumberValidator } from '../types/number';\nimport { BooleanValidator } from '../types/boolean';\nimport { ArrayValidator } from '../types/array';\nimport { JsonValidator } from '../types/json';\nimport { VoidValidator } from \"../types/void\";\nimport { DateValidator } from '../types/date';\nimport { DateTimeValidator } from '../types/datetime';\nimport { UrlValidator } from \"../types/url\";\nimport { HexColorValidator } from \"../types/hexcolor\";\nimport { EmailValidator } from \"../types/email\";\nimport { TimeValidator } from '../types/time';\nimport { RgbaValidator } from '../types/rgba';\nimport { ColorValidator } from '../types/color';\nimport { UUIDValidator } from \"../types/uuid\";\nimport { IPAddressValidator } from \"../types/ipaddress\";\nimport { PercentageValidator } from \"../types/percentage\";\nimport { EnumValidator } from \"../types/enum\";\nimport { UnionValidator } from \"../types/union\";\nimport { AnyValidator } from \"../types/any\";\nimport { TextValidator } from \"../types/text\";\nimport { VarcharValidator } from \"../types/varchar\";\nimport { CharValidator } from \"../types/char\";\n\nimport { ValidationError } from './errors';\n\n/**\n * Process escape sequences in a field value\n * Handles common escape sequences: \\n, \\t, \\r, \\\\, \\\"\n */\nfunction processEscapeSequences(value: string): string {\n    return value\n        .replace(/\\\\n/g, '\\n')    // Newline\n        .replace(/\\\\t/g, '\\t')    // Tab\n        .replace(/\\\\r/g, '\\r')    // Carriage return\n        .replace(/\\\\\"/g, '\"')     // Quote\n        .replace(/\\\\\\\\/g, '\\\\');  // Backslash (must be last)\n}\n\nconst validators: Record<SupportedType, TypeValidator> = {\n    string: new StringValidator(),\n    number: new NumberValidator(),\n    boolean: new BooleanValidator(),\n    array: new ArrayValidator(),\n    json: new JsonValidator(),\n    void: new VoidValidator(),\n    date: new DateValidator(),\n    datetime: new DateTimeValidator(),\n    url: new UrlValidator(),\n    hexcolor: new HexColorValidator(),\n    email: new EmailValidator(),\n    time: new TimeValidator(),\n    rgba: new RgbaValidator(),\n    color: new ColorValidator(),\n    uuid: new UUIDValidator(),\n    ipaddress: new IPAddressValidator(),\n    percentage: new PercentageValidator(),\n    enum: new EnumValidator(),\n    union: new UnionValidator(),\n    any: new AnyValidator(),\n    text: new TextValidator(),\n    varchar: new VarcharValidator(),\n    char: new CharValidator()\n};\n\nexport function getValidator(type: SupportedType): TypeValidator {\n    const validator = validators[type];\n    if (!validator) {\n        throw new Error(`Unsupported type: ${type}`);\n    }\n    return validator;\n};\n\nexport function validateValue(value: string, column: CSVTColumn, lineNumber?: number, processEscapes?: boolean): any {\n    try {\n        const validator = getValidator(column.type);\n        \n        // Prepare options for validators that need them\n        const options: any = {};\n        if (column.type === 'enum' && column.enumValues) {\n            options.enumValues = column.enumValues;\n        }\n        if (column.type === 'union' && column.unionTypes) {\n            options.unionTypes = column.unionTypes;\n        }\n        if (column.type === 'varchar' && column.maxLength) {\n            options.maxLength = column.maxLength;\n        }\n        if (column.type === 'char' && column.length) {\n            options.length = column.length;\n        }\n        \n        if (!validator.validate(value, options)) {\n            throw new ValidationError(\n                `Invalid ${column.type} value: \"${value}\"${column.name ? ` in column \"${column.name}\"` : ''}`,\n                column.type,\n                value,\n                lineNumber,\n                column.name\n            );\n        }\n        \n        const parsedValue = validator.parse(value, options);\n        \n        // Apply escape processing only to string types (not complex types like JSON/array)\n        if (processEscapes && column.type === 'string') {\n            return processEscapeSequences(parsedValue);\n        }\n        \n        // For union types, apply escape processing only if the final parsed value is a string\n        if (processEscapes && column.type === 'union' && typeof parsedValue === 'string') {\n            return processEscapeSequences(parsedValue);\n        }\n        \n        return parsedValue;\n    } catch (error) {\n        if (error instanceof ValidationError) {\n            // Update error with context if not already set\n            if (!error.line && lineNumber) {\n                (error as any).line = lineNumber;\n            }\n            if (!error.column && column.name) {\n                (error as any).column = column.name;\n            }\n            throw error;\n        }\n        \n        throw new ValidationError(\n            `Validation failed for ${column.type}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            column.type,\n            value,\n            lineNumber,\n            column.name\n        );\n    }\n};\n\nexport function serializeValue(value: any, column: CSVTColumn): string {\n    const validator = getValidator(column.type);\n    \n    // Prepare options for validators that need them\n    const options: any = {};\n    if (column.type === 'enum' && column.enumValues) {\n        options.enumValues = column.enumValues;\n    }\n    if (column.type === 'union' && column.unionTypes) {\n        options.unionTypes = column.unionTypes;\n    }\n    if (column.type === 'varchar' && column.maxLength) {\n        options.maxLength = column.maxLength;\n    }\n    if (column.type === 'char' && column.length) {\n        options.length = column.length;\n    }\n    \n    return validator.serialize(value, options);\n};\n\nexport function isSupportedType(type: string): type is SupportedType {\n    return type in validators;\n};\n", "/**\n * Core CSV parsing functionality\n */\n\nimport { CSVTColumn, CSVTOptions, CSVTResult, SupportedType } from '../types';\nimport { validateValue, isSupportedType } from './validation';\nimport { ParseError, ValidationError } from './errors';\n\nconst DEFAULT_OPTIONS: Required<CSVTOptions> = {\n    delimiter: ',',\n    quote: '\"',\n    escape: '\"',\n    skipEmptyLines: true,\n    trim: true,\n    strict: false,\n    processEscapes: false\n};\n\nexport function parseCSVT(csvtContent: string, options: CSVTOptions = {}): Promise<CSVTResult> {\n    return Promise.resolve(parseCSVTSync(csvtContent, options));\n};\n\nexport function parseCSVTSync(csvtContent: string, options: CSVTOptions = {}): CSVTResult {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const lines = csvtContent.split('\\n').filter(line => \n        !opts.skipEmptyLines || line.trim() !== ''\n    );\n\n    if (lines.length === 0) {\n        throw new ParseError('Empty CSVT content', csvtContent);\n    }\n\n    // Parse header with type definitions\n    const headerLine = lines[0];\n    if (!headerLine) {\n        throw new ParseError('Missing header line', csvtContent);\n    }\n    const columns = parseHeader(headerLine, opts);\n    \n    // Parse data rows\n    const data: any[] = [];\n    const errors: any[] = [];\n\n    for (let i = 1; i < lines.length; i++) {\n        try {\n            const currentLine = lines[i];\n            if (!currentLine) continue;\n            \n            const row = parseDataRow(currentLine, columns, opts, i + 1);\n            if (row !== null) {\n                data.push(row);\n            }\n        } catch (error) {\n            if (opts.strict) {\n                throw error;\n            } else {\n                errors.push({\n                    line: i + 1,\n                    error: error instanceof Error ? error.message : String(error),\n                    rawData: lines[i] || ''\n                });\n            }\n        }\n    }\n\n    return {\n        data,\n        columns,\n        errors\n    };\n};\n\nfunction parseHeader(headerLine: string, options: Required<CSVTOptions>): CSVTColumn[] {\n    const columns: CSVTColumn[] = [];\n    const fields = splitCSVLine(headerLine, options);\n\n    for (const field of fields) {\n        const trimmed = options.trim ? field.trim() : field;\n        \n        if (!trimmed.includes(':')) {\n            throw new ParseError(\n                `Invalid column definition: \"${trimmed}\". Expected format: \"name:type\"`,\n                headerLine,\n                1\n            );\n        }\n\n        const [name, typeDefinition] = trimmed.split(':', 2);\n        \n        if (!name || !typeDefinition) {\n            throw new ParseError(\n                `Invalid column definition: \"${trimmed}\". Both name and type are required`,\n                headerLine,\n                1\n            );\n        }\n\n        const cleanName = name.trim();\n        const column = parseTypeDefinition(cleanName, typeDefinition.trim(), headerLine);\n        \n        columns.push(column);\n    }\n\n    return columns;\n}\n\nfunction parseTypeDefinition(name: string, typeDefinition: string, headerLine: string): CSVTColumn {\n    // Handle union types (e.g., \"string|number|boolean\")\n    if (typeDefinition.includes('|')) {\n        const unionTypes = typeDefinition.split('|').map(t => t.trim());\n        \n        // Validate all union types\n        for (const unionType of unionTypes) {\n            if (!isSupportedType(unionType)) {\n                throw new ParseError(\n                    `Unsupported type in union: \"${unionType}\". Supported types: string, number, boolean, array, json, enum, any, etc.`,\n                    headerLine,\n                    1\n                );\n            }\n        }\n        \n        return {\n            name,\n            type: 'union',\n            unionTypes: unionTypes as SupportedType[]\n        };\n    }\n    \n    // Handle enum types (e.g., \"enum(pending,approved,rejected)\")\n    if (typeDefinition.startsWith('enum(') && typeDefinition.endsWith(')')) {\n        const enumValuesStr = typeDefinition.slice(5, -1); // Remove \"enum(\" and \")\"\n        const enumValues = enumValuesStr.split(',').map(v => v.trim()).filter(v => v !== '');\n        \n        if (enumValues.length === 0) {\n            throw new ParseError(\n                `Enum type requires at least one value: \"${typeDefinition}\"`,\n                headerLine,\n                1\n            );\n        }\n        \n        return {\n            name,\n            type: 'enum',\n            enumValues\n        };\n    }\n    \n    // Handle parameterized types (e.g., \"varchar(20)\", \"char(5)\")\n    if (typeDefinition.includes('(') && typeDefinition.includes(')')) {\n        const parenIndex = typeDefinition.indexOf('(');\n        const baseType = typeDefinition.substring(0, parenIndex).trim();\n        const paramStr = typeDefinition.substring(parenIndex + 1, typeDefinition.lastIndexOf(')')).trim();\n        \n        if (baseType === 'varchar') {\n            const maxLength = parseInt(paramStr, 10);\n            if (isNaN(maxLength) || maxLength <= 0) {\n                throw new ParseError(\n                    `Invalid varchar length: \"${paramStr}\". Must be a positive integer.`,\n                    headerLine,\n                    1\n                );\n            }\n            return {\n                name,\n                type: 'varchar',\n                maxLength\n            };\n        }\n        \n        if (baseType === 'char') {\n            const length = parseInt(paramStr, 10);\n            if (isNaN(length) || length <= 0) {\n                throw new ParseError(\n                    `Invalid char length: \"${paramStr}\". Must be a positive integer.`,\n                    headerLine,\n                    1\n                );\n            }\n            return {\n                name,\n                type: 'char',\n                length\n            };\n        }\n        \n        throw new ParseError(\n            `Unsupported parameterized type: \"${baseType}\". Supported parameterized types: varchar(n), char(n)`,\n            headerLine,\n            1\n        );\n    }\n    \n    // Handle simple types\n    const cleanType = typeDefinition.trim() as SupportedType;\n    \n    if (!isSupportedType(cleanType)) {\n        throw new ParseError(\n            `Unsupported type: \"${cleanType}\". Supported types: string, number, boolean, array, json, enum, union, any, text, varchar, char, etc.`,\n            headerLine,\n            1\n        );\n    }\n    \n    return {\n        name,\n        type: cleanType\n    };\n}\n\nfunction parseDataRow(\n    line: string, \n    columns: CSVTColumn[], \n    options: Required<CSVTOptions>,\n    lineNumber: number\n): any | null {\n    const trimmed = options.trim ? line.trim() : line;\n    \n    if (options.skipEmptyLines && trimmed === '') {\n        return null;\n    }\n\n    const fields = splitCSVLine(line, options);\n    \n    if (fields.length !== columns.length) {\n        throw new ParseError(\n            `Column count mismatch. Expected ${columns.length} columns, got ${fields.length}`,\n            line,\n            lineNumber\n        );\n    }\n\n    const row: any = {};\n\n    for (let i = 0; i < columns.length; i++) {\n        const column = columns[i];\n        if (!column) continue;\n        \n        let fieldValue = fields[i];\n        if (!fieldValue) fieldValue = '';\n        \n        if (options.trim) {\n            fieldValue = fieldValue.trim();\n        }\n\n        try {\n            row[column.name] = validateValue(fieldValue, column, lineNumber, options.processEscapes);\n        } catch (error) {\n            if (error instanceof ValidationError) {\n                throw error;\n            }\n            throw new ValidationError(\n                `Failed to parse field \"${column.name}\": ${error instanceof Error ? error.message : String(error)}`,\n                column.type,\n                fieldValue,\n                lineNumber,\n                column.name\n            );\n        }\n    }\n\n    return row;\n}\n\nfunction splitCSVLine(line: string, options: Required<CSVTOptions>): string[] {\n    const fields: string[] = [];\n    let current = '';\n    let inQuotes = false;\n    let inParentheses = 0;\n    let i = 0;\n\n    while (i < line.length) {\n        const char = line[i];\n        \n        if (char === options.quote) {\n            if (inQuotes && i + 1 < line.length && line[i + 1] === options.quote) {\n                // Escaped quote\n                current += options.quote;\n                i += 2;\n            } else {\n                // Toggle quote state\n                inQuotes = !inQuotes;\n                i++;\n            }\n        } else if (char === '(' && !inQuotes) {\n            inParentheses++;\n            current += char;\n            i++;\n        } else if (char === ')' && !inQuotes) {\n            inParentheses = Math.max(0, inParentheses - 1);\n            current += char;\n            i++;\n        } else if (char === options.delimiter && !inQuotes && inParentheses === 0) {\n            // End of field (only split on delimiter when not in quotes and not in parentheses)\n            fields.push(current);\n            current = '';\n            i++;\n        } else {\n            current += char;\n            i++;\n        }\n    }\n\n    // Add the last field\n    fields.push(current);\n\n    return fields;\n}\n", "/**\n * File reading functionality\n */\n\nimport * as fs from 'fs';\nimport { promisify } from 'util';\nimport { parseCSVT, parseCSVTSync } from './parse';\nimport { CSVTOptions, CSVTResult } from '../types';\nimport { FileError } from './errors';\n\nconst readFileAsync = promisify(fs.readFile);\n\nexport async function readFile(filename: string, options: CSVTOptions = {}): Promise<CSVTResult> {\n    try {\n        const content = await readFileAsync(filename, 'utf8');\n        return parseCSVT(content, options);\n    } catch (error) {\n        if (error instanceof Error && 'code' in error) {\n            const fsError = error as NodeJS.ErrnoException;\n            if (fsError.code === 'ENOENT') {\n                throw new FileError(`File not found: ${filename}`, filename, 'read');\n            }\n            if (fsError.code === 'EACCES') {\n                throw new FileError(`Permission denied: ${filename}`, filename, 'read');\n            }\n        }\n        \n        throw new FileError(\n            `Failed to read file: ${filename}. ${error instanceof Error ? error.message : String(error)}`,\n            filename,\n            'read'\n        );\n    }\n};\n\nexport function readFileSync(filename: string, options: CSVTOptions = {}): CSVTResult {\n    try {\n        const content = fs.readFileSync(filename, 'utf8');\n        return parseCSVTSync(content, options);\n    } catch (error) {\n        if (error instanceof Error && 'code' in error) {\n            const fsError = error as NodeJS.ErrnoException;\n            if (fsError.code === 'ENOENT') {\n                throw new FileError(`File not found: ${filename}`, filename, 'read');\n            }\n            if (fsError.code === 'EACCES') {\n                throw new FileError(`Permission denied: ${filename}`, filename, 'read');\n            }\n        }\n        \n        throw new FileError(\n            `Failed to read file: ${filename}. ${error instanceof Error ? error.message : String(error)}`,\n            filename,\n            'read'\n        );\n    }\n};\n", "/**\n * File writing functionality\n */\n\nimport * as fs from 'fs';\nimport { promisify } from 'util';\nimport { CSVTColumn, CSVTOptions } from '../types';\nimport { serializeValue } from './validation';\nimport { FileError } from './errors';\n\nconst writeFileAsync = promisify(fs.writeFile);\n\nconst DEFAULT_WRITE_OPTIONS: Required<Omit<CSVTOptions, 'skipEmptyLines' | 'trim' | 'strict'>> = {\n    delimiter: ',',\n    quote: '\"',\n    escape: '\"',\n    processEscapes: false\n};\n\nexport async function writeFile(\n    filename: string, \n    data: any[], \n    columns: CSVTColumn[], \n    options: Omit<CSVTOptions, 'skipEmptyLines' | 'trim' | 'strict'> = {}\n): Promise<void> {\n    const content = serializeCSVTInternal(data, columns, options);\n    \n    try {\n        await writeFileAsync(filename, content, 'utf8');\n    } catch (error) {\n        if (error instanceof Error && 'code' in error) {\n            const fsError = error as NodeJS.ErrnoException;\n            if (fsError.code === 'EACCES') {\n                throw new FileError(`Permission denied: ${filename}`, filename, 'write');\n            }\n            if (fsError.code === 'ENOSPC') {\n                throw new FileError(`No space left on device: ${filename}`, filename, 'write');\n            }\n        }\n        \n        throw new FileError(\n            `Failed to write file: ${filename}. ${error instanceof Error ? error.message : String(error)}`,\n            filename,\n            'write'\n        );\n    }\n};\n\nexport function writeFileSync(\n    filename: string, \n    data: any[], \n    columns: CSVTColumn[], \n    options: Omit<CSVTOptions, 'skipEmptyLines' | 'trim' | 'strict'> = {}\n): void {\n    const content = serializeCSVTInternal(data, columns, options);\n    \n    try {\n        fs.writeFileSync(filename, content, 'utf8');\n    } catch (error) {\n        if (error instanceof Error && 'code' in error) {\n            const fsError = error as NodeJS.ErrnoException;\n            if (fsError.code === 'EACCES') {\n                throw new FileError(`Permission denied: ${filename}`, filename, 'write');\n            }\n            if (fsError.code === 'ENOSPC') {\n                throw new FileError(`No space left on device: ${filename}`, filename, 'write');\n            }\n        }\n        \n        throw new FileError(\n            `Failed to write file: ${filename}. ${error instanceof Error ? error.message : String(error)}`,\n            filename,\n            'write'\n        );\n    }\n};\n\nfunction serializeCSVTInternal(\n    data: any[], \n    columns: CSVTColumn[], \n    options: Omit<CSVTOptions, 'skipEmptyLines' | 'trim' | 'strict'> = {}\n): string {\n    const opts = { ...DEFAULT_WRITE_OPTIONS, ...options };\n    const lines: string[] = [];\n\n    // Create header line with type definitions\n    const headerFields = columns.map(col => `${col.name}:${col.type}`);\n    lines.push(headerFields.join(opts.delimiter));\n\n    // Serialize data rows\n    for (const row of data) {\n        const fields: string[] = [];\n        \n        for (const column of columns) {\n            const value = row[column.name];\n            \n            if (value === null || value === undefined) {\n                fields.push('');\n            } else {\n                try {\n                    const serialized = serializeValue(value, column);\n                    fields.push(serialized);\n                } catch (error) {\n                    throw new Error(\n                        `Failed to serialize value for column \"${column.name}\": ${\n                            error instanceof Error ? error.message : String(error)\n                        }`\n                    );\n                }\n            }\n        }\n        \n        lines.push(fields.join(opts.delimiter));\n    }\n\n    return lines.join('\\n');\n}\n\nexport function serializeCSVT(\n    data: any[], \n    columns: CSVTColumn[], \n    options: Omit<CSVTOptions, 'skipEmptyLines' | 'trim' | 'strict'> = {}\n): string {\n    return serializeCSVTInternal(data, columns, options);\n};\n", "/**\n * CSVT-Parse - CSV with Type definitions parser\n * Copyright (c) 2025 - All rights reserved\n * \n * Main entry point for the csvt-parse library\n */\n\nimport { parseCSVT, parseCSVTSync } from './lib/parse';\nimport { readFile, readFileSync } from './lib/readFile';\nimport { writeFile, writeFileSync } from './lib/writeFile';\nimport { validateValue } from './lib/validation';\nimport { CSVTError, ValidationError, ParseError } from './lib/errors';\nimport { \n    CSVTOptions, \n    CSVTColumn, \n    CSVTResult, \n    TypeValidator,\n    SupportedType \n} from './types';\n\n// Main parsing functions\nexport {\n    parseCSVT,\n    parseCSVTSync,\n    readFile,\n    readFileSync,\n    writeFile,\n    writeFileSync,\n    validateValue\n};\n\n// Error classes\nexport {\n    CSVTError,\n    ValidationError,\n    ParseError\n};\n\n// Type definitions\nexport {\n    CSVTOptions,\n    CSVTColumn,\n    CSVTResult,\n    TypeValidator,\n    SupportedType\n};\n\n// Default export for convenience\nexport default {\n    parse: parseCSVT,\n    parseSync: parseCSVTSync,\n    readFile,\n    readFileSync,\n    writeFile,\n    writeFileSync,\n    validateValue,\n    CSVTError,\n    ValidationError,\n    ParseError\n};\n"],
  "mappings": "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",
  "names": ["StringValidator", "_value", "value", "exports", "CSVTError", "_CSVTError", "message", "code", "line", "column", "exports", "ValidationError", "expectedType", "actualValue", "ParseError", "rawData", "FileError", "filename", "operation", "errors_1", "NumberValidator", "value", "trimmed", "num", "exports", "errors_1", "BooleanValidator", "_BooleanValidator", "value", "trimmed", "exports", "errors_1", "ArrayValidator", "value", "trimmed", "parsed", "error", "exports", "errors_1", "JsonValidator", "value", "trimmed", "parsed", "error", "exports", "errors_1", "VoidValidator", "value", "trimmed", "exports", "errors_1", "DateValidator", "value", "trimmed", "date", "year", "month", "day", "exports", "errors_1", "DateTimeValidator", "value", "trimmed", "date", "exports", "errors_1", "UrlValidator", "value", "url", "exports", "errors_1", "HEXCOLOR_REGEX", "HexColorValidator", "value", "exports", "errors_1", "EMAIL_REGEX", "EmailValidator", "value", "exports", "errors_1", "TimeValidator", "value", "trimmed", "exports", "errors_1", "RGBA_REGEX", "RgbaValidator", "value", "trimmed", "exports", "errors_1", "HEX_COLOR_REGEX", "CSS_COLOR_NAMES", "ColorValidator", "value", "trimmed", "exports", "errors_1", "UUID_REGEX", "UUIDValidator", "value", "exports", "errors_1", "IPV4_REGEX", "IPV6_REGEX", "IPAddressValidator", "value", "trimmed", "exports", "errors_1", "PERCENTAGE_REGEX", "PercentageValidator", "value", "trimmed", "match", "exports", "errors_1", "EnumValidator", "value", "options", "trimmed", "exports", "errors_1", "validation_1", "UnionValidator", "value", "options", "type", "errors", "validator", "error", "exports", "AnyValidator", "_value", "value", "trimmed", "num", "lowerTrimmed", "exports", "TextValidator", "_value", "value", "exports", "VarcharValidator", "value", "options", "_options", "stringValue", "exports", "CharValidator", "value", "options", "stringValue", "exports", "exports", "getValidator", "validateValue", "serializeValue", "isSupportedType", "string_1", "number_1", "boolean_1", "array_1", "json_1", "void_1", "date_1", "datetime_1", "url_1", "hexcolor_1", "email_1", "time_1", "rgba_1", "color_1", "uuid_1", "ipaddress_1", "percentage_1", "enum_1", "union_1", "any_1", "text_1", "varchar_1", "char_1", "errors_1", "processEscapeSequences", "value", "validators", "type", "validator", "column", "lineNumber", "processEscapes", "options", "parsedValue", "error", "exports", "parseCSVT", "parseCSVTSync", "validation_1", "errors_1", "DEFAULT_OPTIONS", "csvtContent", "options", "opts", "lines", "line", "headerLine", "columns", "parseHeader", "data", "errors", "i", "currentLine", "row", "parseDataRow", "error", "fields", "splitCSVLine", "field", "trimmed", "name", "typeDefinition", "cleanName", "column", "parseTypeDefinition", "unionTypes", "t", "unionType", "enumValues", "v", "parenIndex", "baseType", "paramStr", "maxLength", "length", "cleanType", "lineNumber", "fieldValue", "current", "inQuotes", "inParentheses", "char", "exports", "readFile", "readFileSync", "fs", "__importStar", "util_1", "parse_1", "errors_1", "readFileAsync", "filename", "options", "content", "error", "fsError", "exports", "writeFile", "writeFileSync", "serializeCSVT", "fs", "__importStar", "util_1", "validation_1", "errors_1", "writeFileAsync", "DEFAULT_WRITE_OPTIONS", "filename", "data", "columns", "options", "content", "serializeCSVTInternal", "error", "fsError", "opts", "lines", "headerFields", "col", "row", "fields", "column", "value", "serialized", "parse_1", "readFile_1", "writeFile_1", "validation_1", "errors_1"]
}
